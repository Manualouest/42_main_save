/* main.c generated by valac 0.57.0.224-bccf, the Vala compiler
 * generated from main.vala, do not modify */

/*valac main.vala window.vala --pkg=gtk+-3.0*/

#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib/gstdio.h>
#include <gtk/gtk.h>
#include <glib-object.h>

#define css_data "\n" \
"\n" \
"#menu {\n" \
"\tpadding:8px;\n" \
"}\n" \
"\n" \
".right{\n" \
"\tborder-radius: 0px 25px 25px 0px / 0px 50px 50px 0px;\n" \
"}\n" \
".left{\n" \
"\tborder-radius: 25px 0px 0px 25px / 50px 0px 0px 50px;\n" \
"}\n"
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_WINDOW (window_get_type ())
#define WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WINDOW, Window))
#define WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WINDOW, WindowClass))
#define IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WINDOW))
#define IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WINDOW))
#define WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WINDOW, WindowClass))

typedef struct _Window Window;
typedef struct _WindowClass WindowClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

VALA_EXTERN const gchar* PUSH_SWAP_EMP;
const gchar* PUSH_SWAP_EMP = NULL;

VALA_EXTERN gchar* search_path (void);
static gint _vala_main (gchar** args,
                 gint args_length1);
static void _vala_array_add1 (gint* * array,
                       gint* length,
                       gint* size,
                       gint value);
VALA_EXTERN Window* window_new (gint nb,
                    gint** range,
                    gint* range_length1);
VALA_EXTERN Window* window_construct (GType object_type,
                          gint nb,
                          gint** range,
                          gint* range_length1);
VALA_EXTERN GType window_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Window, g_object_unref)

gchar*
search_path (void)
{
	gchar* result;
	g_print ("recherche de:	 ./push_swap\n");
	if (g_file_test ("push_swap", G_FILE_TEST_EXISTS | G_FILE_TEST_IS_EXECUTABLE)) {
		gchar* _tmp0_;
		g_chmod ("push_swap", 0000755);
		_tmp0_ = g_strdup ("push_swap");
		result = _tmp0_;
		return result;
	}
	g_print ("recherche de:	 ../push_swap\n");
	if (g_file_test ("../push_swap", G_FILE_TEST_EXISTS | G_FILE_TEST_IS_EXECUTABLE)) {
		gchar* _tmp1_;
		g_chmod ("../push_swap", 0000755);
		_tmp1_ = g_strdup ("../push_swap");
		result = _tmp1_;
		return result;
	}
	g_printerr ("le programme push_swap n'existe pas ou n'est pas executable.\n");
	result = NULL;
	return result;
}

static void
_vala_array_add1 (gint* * array,
                  gint* length,
                  gint* size,
                  gint value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gint, *array, *size);
	}
	(*array)[(*length)++] = value;
}

static gint
_vala_main (gchar** args,
            gint args_length1)
{
	gchar* path = NULL;
	gint* range_nb = NULL;
	gint* _tmp0_;
	gint range_nb_length1;
	gint _range_nb_size_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	gint nb = 0;
	const gchar* _tmp7_;
	gboolean _tmp8_ = FALSE;
	gint result;
	_tmp0_ = g_new0 (gint, 0);
	range_nb = _tmp0_;
	range_nb_length1 = 0;
	_range_nb_size_ = range_nb_length1;
	_tmp1_ = search_path ();
	_g_free0 (path);
	path = _tmp1_;
	_tmp2_ = path;
	if (_tmp2_ == NULL) {
		result = -1;
		range_nb = (g_free (range_nb), NULL);
		_g_free0 (path);
		return result;
	}
	_tmp3_ = path;
	PUSH_SWAP_EMP = _tmp3_;
	_tmp4_ = args[1];
	if (_tmp4_ == NULL) {
		g_printerr ("Il manque un parametre : visualizer 1-1000\n");
		result = -1;
		range_nb = (g_free (range_nb), NULL);
		_g_free0 (path);
		return result;
	}
	if (args_length1 >= 3) {
		{
			gchar** i_collection = NULL;
			gint i_collection_length1 = 0;
			gint _i_collection_size_ = 0;
			gint i_it = 0;
			i_collection = args + 1;
			i_collection_length1 = args_length1 - 1;
			for (i_it = 0; i_it < i_collection_length1; i_it = i_it + 1) {
				gchar* _tmp5_;
				gchar* i = NULL;
				_tmp5_ = g_strdup (i_collection[i_it]);
				i = _tmp5_;
				{
					const gchar* _tmp6_;
					_tmp6_ = i;
					_vala_array_add1 (&range_nb, &range_nb_length1, &_range_nb_size_, atoi (_tmp6_));
					_g_free0 (i);
				}
			}
		}
	}
	_tmp7_ = args[1];
	nb = atoi (_tmp7_);
	if (nb >= 1) {
		_tmp8_ = nb <= 1000;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		Window* _tmp9_;
		Window* _tmp10_;
		gtk_init ((gint*) (&args_length1), &args);
		_tmp9_ = window_new (nb, &range_nb, &range_nb_length1);
		g_object_ref_sink (_tmp9_);
		_tmp10_ = _tmp9_;
		_g_object_unref0 (_tmp10_);
		gtk_main ();
		result = 0;
		range_nb = (g_free (range_nb), NULL);
		_g_free0 (path);
		return result;
	}
	g_printerr ("Un nombre entre 1 et 1000\n");
	result = -1;
	range_nb = (g_free (range_nb), NULL);
	_g_free0 (path);
	return result;
}

int
main (int argc,
      char ** argv)
{
	return _vala_main (argv, argc);
}

