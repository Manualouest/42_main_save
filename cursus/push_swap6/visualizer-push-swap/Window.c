/* Window.c generated by valac 0.57.0.224-bccf, the Vala compiler
 * generated from Window.vala, do not modify */

#include <gtk/gtk.h>
#include <glib-object.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>
#include <gio/gio.h>

#define css_data "\n" \
"\n" \
"#menu {\n" \
"\tpadding:8px;\n" \
"}\n" \
"\n" \
".right{\n" \
"\tborder-radius: 0px 25px 25px 0px / 0px 50px 50px 0px;\n" \
"}\n" \
".left{\n" \
"\tborder-radius: 25px 0px 0px 25px / 50px 0px 0px 50px;\n" \
"}\n"
#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_WINDOW (window_get_type ())
#define WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WINDOW, Window))
#define WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WINDOW, WindowClass))
#define IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WINDOW))
#define IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WINDOW))
#define WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WINDOW, WindowClass))

typedef struct _Window Window;
typedef struct _WindowClass WindowClass;
typedef struct _WindowPrivate WindowPrivate;

#define TYPE_DRAW_STACK (draw_stack_get_type ())
#define DRAW_STACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DRAW_STACK, DrawStack))
#define DRAW_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DRAW_STACK, DrawStackClass))
#define IS_DRAW_STACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DRAW_STACK))
#define IS_DRAW_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DRAW_STACK))
#define DRAW_STACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DRAW_STACK, DrawStackClass))

typedef struct _DrawStack DrawStack;
typedef struct _DrawStackClass DrawStackClass;

#define TYPE_MENU (menu_get_type ())
#define MENU(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MENU, Menu))
#define MENU_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MENU, MenuClass))
#define IS_MENU(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MENU))
#define IS_MENU_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MENU))
#define MENU_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MENU, MenuClass))

typedef struct _Menu Menu;
typedef struct _MenuClass MenuClass;
enum  {
	WINDOW_0_PROPERTY,
	WINDOW_NUM_PROPERTIES
};
static GParamSpec* window_properties[WINDOW_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_thread_unref0(var) ((var == NULL) ? NULL : (var = (g_thread_unref (var), NULL)))
typedef struct _WindowLoadingData WindowLoadingData;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
typedef struct _WindowRunProgrammeData WindowRunProgrammeData;
typedef enum  {
	TYPE_EVENT_CONTINUE,
	TYPE_EVENT_NEW,
	TYPE_EVENT_STOP,
	TYPE_EVENT_STEP,
	TYPE_EVENT_BACKSTEP,
	TYPE_EVENT_REVERSE,
	TYPE_EVENT_FORWARD
} TypeEvent;

#define TYPE_TYPE_EVENT (type_event_get_type ())

struct _Window {
	GtkWindow parent_instance;
	WindowPrivate * priv;
};

struct _WindowClass {
	GtkWindowClass parent_class;
};

struct _WindowPrivate {
	gboolean _is_killing;
	gboolean _is_stop;
	gboolean _is_step;
	gboolean _is_backstep;
	gboolean _is_replay;
	gboolean _is_running;
	gboolean _is_reverse;
	gboolean _is_scaling;
	DrawStack* draw_stackA;
	DrawStack* draw_stackB;
	Menu* menu;
	GtkBox* box;
	GtkNotebook* book;
	GtkScale* scale;
	gint target;
	gint* range;
	gint range_length1;
	gint _range_size_;
	gint _speed;
	gchar* stream;
	gint* tab;
	gint tab_length1;
	gint _tab_size_;
	gint nb_max;
	GQueue* stackA;
	GQueue* stackB;
};

struct _Block1Data {
	int _ref_count_;
	Window* self;
	gpointer _async_data_;
};

struct _WindowLoadingData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	Window* self;
	Block1Data* _data1_;
	gboolean _tmp0_;
	GtkNotebook* _tmp1_;
	gboolean _tmp2_;
	GtkNotebook* _tmp3_;
	gboolean _tmp4_;
	gint _tmp5_;
	gint* _tmp6_;
	GThread* thread;
	GThread* _tmp7_;
	GThread* _tmp8_;
	gpointer _tmp9_;
	GQueue* _tmp10_;
	GQueue* _tmp11_;
	Menu* _tmp12_;
	gint* _tmp13_;
	gint _tmp13__length1;
	gint* i_collection;
	gint i_collection_length1;
	gint _i_collection_size_;
	gint i_it;
	gint i;
	GQueue* _tmp14_;
	GtkNotebook* _tmp15_;
	const gchar* _tmp16_;
};

struct _WindowRunProgrammeData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	Window* self;
	gchar* stream;
	gchar** split;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar** _tmp2_;
	gchar** _tmp3_;
	gchar** _tmp4_;
	gint _tmp4__length1;
	gint split_length1;
	gint _split_size_;
	gchar** tmp;
	gchar** _tmp5_;
	gint tmp_length1;
	gint _tmp_size_;
	gint split_len;
	gint count;
	GRegex* regex;
	GRegex* _tmp6_;
	gchar** _tmp7_;
	gint _tmp7__length1;
	gchar** i_collection;
	gint i_collection_length1;
	gint _i_collection_size_;
	gint i_it;
	gchar* _tmp8_;
	gchar* i;
	GRegex* _tmp9_;
	const gchar* _tmp10_;
	const gchar* _tmp11_;
	gchar* _tmp12_;
	gchar** _tmp13_;
	gint _tmp13__length1;
	gchar** _tmp14_;
	gint _tmp14__length1;
	gchar** _tmp15_;
	gint _tmp15__length1;
	GtkScale* _tmp16_;
	GtkScale* _tmp17_;
	gint _tmp18_;
	gboolean _tmp19_;
	gboolean _tmp20_;
	gboolean _tmp21_;
	gboolean _tmp22_;
	gint _tmp23_;
	gboolean _tmp24_;
	gint _tmp25_;
	gboolean _tmp26_;
	gboolean _tmp27_;
	gboolean _tmp28_;
	gboolean _tmp29_;
	gboolean _tmp30_;
	gint _tmp31_;
	gint _tmp32_;
	gchar** _tmp33_;
	gint _tmp33__length1;
	const gchar* _tmp34_;
	gint _tmp35_;
	gchar** _tmp36_;
	gint _tmp36__length1;
	const gchar* _tmp37_;
	gint _tmp38_;
	GtkScale* _tmp39_;
	Menu* _tmp40_;
	Menu* _tmp41_;
	gchar** _tmp42_;
	gint _tmp42__length1;
	const gchar* _tmp43_;
	DrawStack* _tmp44_;
	DrawStack* _tmp45_;
};

static gint Window_private_offset;
static gpointer window_parent_class = NULL;
VALA_EXTERN const gchar* PUSH_SWAP_EMP;

VALA_EXTERN GType window_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Window, g_object_unref)
VALA_EXTERN GType draw_stack_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (DrawStack, g_object_unref)
VALA_EXTERN GType menu_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Menu, g_object_unref)
VALA_EXTERN Window* window_new (gint nb,
                    gint** range,
                    gint* range_length1);
VALA_EXTERN Window* window_construct (GType object_type,
                          gint nb,
                          gint** range,
                          gint* range_length1);
VALA_EXTERN DrawStack* draw_stack_new (GQueue** stack,
                           gint len_max);
VALA_EXTERN DrawStack* draw_stack_construct (GType object_type,
                                 GQueue** stack,
                                 gint len_max);
VALA_EXTERN Menu* menu_new (void);
VALA_EXTERN Menu* menu_construct (GType object_type);
static gboolean _vala_lambda0_ (Window* self,
                         GtkScrollType a,
                         gdouble b);
static void window_set_is_scaling (Window* self,
                            gboolean value);
static void window_set_is_stop (Window* self,
                         gboolean value);
static void window_set_speed (Window* self,
                       gint value);
VALA_EXTERN void menu_scaling_mode (Menu* self);
static gboolean __vala_lambda0__gtk_range_change_value (GtkRange* _sender,
                                                 GtkScrollType scroll,
                                                 gdouble new_value,
                                                 gpointer self);
static void window_init_event (Window* self);
VALA_EXTERN void window_loading (Window* self,
                     GAsyncReadyCallback _callback_,
                     gpointer _user_data_);
VALA_EXTERN void window_loading_finish (Window* self,
                            GAsyncResult* _res_);
static void window_loading_data_free (gpointer _data);
static gboolean window_loading_co (WindowLoadingData* _data_);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean window_get_is_running (Window* self);
static void window_set_is_killing (Window* self,
                            gboolean value);
static gboolean window_get_is_killing (Window* self);
VALA_EXTERN void utils_sleep (gint time,
                  GAsyncReadyCallback _callback_,
                  gpointer _user_data_);
VALA_EXTERN void utils_sleep_finish (GAsyncResult* _res_);
static void window_loading_ready (GObject* source_object,
                           GAsyncResult* _res_,
                           gpointer _user_data_);
static void window_set_is_running (Window* self,
                            gboolean value);
static gboolean window_get_is_replay (Window* self);
VALA_EXTERN gint* utils_get_random_tab (gint size,
                            gint* result_length1);
static gchar* _vala_lambda1_ (Block1Data* _data1_);
static gboolean _window_loading_co_gsource_func (gpointer self);
static gpointer __vala_lambda1__gthread_func (gpointer self);
VALA_EXTERN void menu_iterate_count (Menu* self,
                         const gchar* line,
                         gint count);
static void window_run_programme (Window* self,
                           const gchar* stream,
                           GAsyncReadyCallback _callback_,
                           gpointer _user_data_);
static void window_run_programme_finish (Window* self,
                                  GAsyncResult* _res_);
static void window_run_programme_data_free (gpointer _data);
static gboolean window_run_programme_co (WindowRunProgrammeData* _data_);
static void _vala_array_add2 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
static gchar** _vala_array_dup1 (gchar** self,
                          gssize length);
VALA_EXTERN void utils_usleep (gint time,
                   GAsyncReadyCallback _callback_,
                   gpointer _user_data_);
VALA_EXTERN void utils_usleep_finish (GAsyncResult* _res_);
static gint window_get_speed (Window* self);
static void window_run_programme_ready (GObject* source_object,
                                 GAsyncResult* _res_,
                                 gpointer _user_data_);
static gboolean window_get_is_stop (Window* self);
static gboolean window_get_is_step (Window* self);
static void window_set_is_step (Window* self,
                         gboolean value);
static gboolean window_get_is_backstep (Window* self);
static void window_set_is_backstep (Window* self,
                             gboolean value);
static gboolean window_get_is_scaling (Window* self);
static gboolean window_get_is_reverse (Window* self);
VALA_EXTERN gboolean window_forward (Window* self,
                         const gchar* line);
VALA_EXTERN gboolean window_reverse (Window* self,
                         const gchar* line);
VALA_EXTERN void rra (GQueue* s_a);
VALA_EXTERN void ra (GQueue* s_a);
VALA_EXTERN void sa (GQueue* s_a);
VALA_EXTERN void pb (GQueue* s_a,
         GQueue* s_b);
VALA_EXTERN void rrb (GQueue* s_b);
VALA_EXTERN void rb (GQueue* s_b);
VALA_EXTERN void sb (GQueue* s_b);
VALA_EXTERN void pa (GQueue* s_a,
         GQueue* s_b);
VALA_EXTERN void ss (GQueue* s_a,
         GQueue* s_b);
VALA_EXTERN void rrr (GQueue* s_a,
          GQueue* s_b);
VALA_EXTERN void rr (GQueue* s_a,
         GQueue* s_b);
static void _vala_lambda2_ (Window* self);
static void __vala_lambda2__gtk_widget_destroy (GtkWidget* _sender,
                                         gpointer self);
static void _vala_lambda3_ (Window* self,
                     gint speed);
static void __vala_lambda3__menu_on_change_speed (Menu* _sender,
                                           gint speed,
                                           gpointer self);
VALA_EXTERN GType type_event_get_type (void) G_GNUC_CONST ;
static void _vala_lambda4_ (Window* self,
                     TypeEvent type);
VALA_EXTERN void menu_refresh_speed (Menu* self);
static gboolean _vala_lambda5_ (Window* self);
static gboolean __vala_lambda5__gsource_func (gpointer self);
static void window_set_is_reverse (Window* self,
                            gboolean value);
static void __vala_lambda4__menu_on_event (Menu* _sender,
                                    TypeEvent type,
                                    gpointer self);
static void window_set_is_replay (Window* self,
                           gboolean value);
static void window_finalize (GObject * obj);
static GType window_get_type_once (void);
static void _vala_window_get_property (GObject * object,
                                guint property_id,
                                GValue * value,
                                GParamSpec * pspec);
static void _vala_window_set_property (GObject * object,
                                guint property_id,
                                const GValue * value,
                                GParamSpec * pspec);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static gssize _vala_array_length (gpointer array);

static GRegex* _tmp_regex_0 = NULL;

static inline gpointer
window_get_instance_private (Window* self)
{
	return G_STRUCT_MEMBER_P (self, Window_private_offset);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static gboolean
_vala_lambda0_ (Window* self,
                GtkScrollType a,
                gdouble b)
{
	GtkScale* _tmp0_;
	GtkScale* _tmp1_;
	Menu* _tmp2_;
	gboolean result;
	_tmp0_ = self->priv->scale;
	gtk_range_set_value ((GtkRange*) _tmp0_, b);
	_tmp1_ = self->priv->scale;
	self->priv->target = (gint) gtk_range_get_value ((GtkRange*) _tmp1_);
	window_set_is_scaling (self, TRUE);
	window_set_is_stop (self, FALSE);
	window_set_speed (self, 0);
	_tmp2_ = self->priv->menu;
	menu_scaling_mode (_tmp2_);
	result = FALSE;
	return result;
}

static gboolean
__vala_lambda0__gtk_range_change_value (GtkRange* _sender,
                                        GtkScrollType scroll,
                                        gdouble new_value,
                                        gpointer self)
{
	gboolean result;
	result = _vala_lambda0_ ((Window*) self, scroll, new_value);
	return result;
}

Window*
window_construct (GType object_type,
                  gint nb,
                  gint** range,
                  gint* range_length1)
{
	Window * self = NULL;
	GtkNotebook* _tmp0_ = NULL;
	GtkBox* _tmp1_;
	GQueue* _tmp2_;
	GQueue* _tmp3_;
	DrawStack* _tmp4_;
	DrawStack* _tmp5_;
	Menu* _tmp6_;
	GtkBox* _tmp7_;
	Menu* _tmp8_;
	GtkBox* _tmp9_;
	DrawStack* _tmp10_;
	GtkBox* _tmp11_;
	DrawStack* _tmp12_;
	GtkNotebook* _tmp13_;
	GtkBox* _tmp14_;
	GtkNotebook* _tmp15_;
	GtkLabel* _tmp16_;
	GtkLabel* _tmp17_;
	GtkBox* top = NULL;
	GtkNotebook* _tmp18_;
	GtkWidget* _tmp19_;
	GtkBox* _tmp20_ = NULL;
	GtkScale* _tmp21_;
	GtkScale* _tmp22_;
	GtkScale* _tmp23_;
	GtkCssProvider* provider = NULL;
	GtkCssProvider* _tmp24_;
	GdkScreen* _tmp27_;
	GError* _inner_error0_ = NULL;
	self = (Window*) g_object_new (object_type, "default-width", 1000, "default-height", 600, NULL);
	self->priv->range = *range;
	self->priv->range_length1 = *range_length1;
	self->priv->_range_size_ = self->priv->range_length1;
	self->priv->nb_max = nb;
	_tmp0_ = (GtkNotebook*) gtk_notebook_new ();
	gtk_notebook_set_show_tabs (_tmp0_, FALSE);
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->book);
	self->priv->book = _tmp0_;
	_tmp1_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp1_);
	_g_object_unref0 (self->priv->box);
	self->priv->box = _tmp1_;
	_tmp2_ = g_queue_new ();
	(self->priv->stackA == NULL) ? NULL : (self->priv->stackA = (g_queue_free (self->priv->stackA), NULL));
	self->priv->stackA = _tmp2_;
	_tmp3_ = g_queue_new ();
	(self->priv->stackB == NULL) ? NULL : (self->priv->stackB = (g_queue_free (self->priv->stackB), NULL));
	self->priv->stackB = _tmp3_;
	_tmp4_ = draw_stack_new (&self->priv->stackA, self->priv->nb_max);
	g_object_ref_sink (_tmp4_);
	_g_object_unref0 (self->priv->draw_stackA);
	self->priv->draw_stackA = _tmp4_;
	_tmp5_ = draw_stack_new (&self->priv->stackB, self->priv->nb_max);
	g_object_ref_sink (_tmp5_);
	_g_object_unref0 (self->priv->draw_stackB);
	self->priv->draw_stackB = _tmp5_;
	_tmp6_ = menu_new ();
	g_object_ref_sink (_tmp6_);
	_g_object_unref0 (self->priv->menu);
	self->priv->menu = _tmp6_;
	_tmp7_ = self->priv->box;
	_tmp8_ = self->priv->menu;
	gtk_box_pack_start (_tmp7_, (GtkWidget*) _tmp8_, FALSE, FALSE, (guint) 0);
	_tmp9_ = self->priv->box;
	_tmp10_ = self->priv->draw_stackA;
	gtk_box_pack_start (_tmp9_, (GtkWidget*) _tmp10_, TRUE, TRUE, (guint) 0);
	_tmp11_ = self->priv->box;
	_tmp12_ = self->priv->draw_stackB;
	gtk_box_pack_start (_tmp11_, (GtkWidget*) _tmp12_, TRUE, TRUE, (guint) 0);
	_tmp13_ = self->priv->book;
	_tmp14_ = self->priv->box;
	gtk_notebook_append_page (_tmp13_, (GtkWidget*) _tmp14_, NULL);
	_tmp15_ = self->priv->book;
	_tmp16_ = (GtkLabel*) gtk_label_new ("Loading");
	g_object_ref_sink (_tmp16_);
	_tmp17_ = _tmp16_;
	gtk_notebook_append_page (_tmp15_, (GtkWidget*) _tmp17_, NULL);
	_g_object_unref0 (_tmp17_);
	_tmp18_ = self->priv->book;
	_tmp19_ = _g_object_ref0 ((GtkWidget*) _tmp18_);
	_tmp20_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_set ((GtkContainer*) _tmp20_, "child", _tmp19_, NULL);
	_g_object_unref0 (_tmp19_);
	g_object_ref_sink (_tmp20_);
	top = _tmp20_;
	_tmp21_ = (GtkScale*) gtk_scale_new_with_range (GTK_ORIENTATION_HORIZONTAL, 0.0, 100.0, 1.0);
	g_object_ref_sink (_tmp21_);
	_g_object_unref0 (self->priv->scale);
	self->priv->scale = _tmp21_;
	_tmp22_ = self->priv->scale;
	g_signal_connect_object ((GtkRange*) _tmp22_, "change-value", (GCallback) __vala_lambda0__gtk_range_change_value, self, 0);
	_tmp23_ = self->priv->scale;
	gtk_box_pack_end (top, (GtkWidget*) _tmp23_, FALSE, TRUE, (guint) 0);
	g_object_set ((GtkContainer*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_window_get_type (), GtkWindow), "child", (GtkWidget*) top, NULL);
	GTK_WIDGET_CLASS (window_parent_class)->show_all ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_window_get_type (), GtkWindow));
	_tmp24_ = gtk_css_provider_new ();
	provider = _tmp24_;
	{
		gtk_css_provider_load_from_data (provider, css_data, (gssize) -1, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp25_;
		const gchar* _tmp26_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp25_ = e;
		_tmp26_ = _tmp25_->message;
		g_warning ("Window.vala:41: %s", _tmp26_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (provider);
		_g_object_unref0 (top);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
	_tmp27_ = gdk_screen_get_default ();
	gtk_style_context_add_provider_for_screen (_tmp27_, (GtkStyleProvider*) provider, (guint) GTK_STYLE_PROVIDER_PRIORITY_USER);
	window_init_event (self);
	window_loading (self, NULL, NULL);
	_g_object_unref0 (provider);
	_g_object_unref0 (top);
	return self;
}

Window*
window_new (gint nb,
            gint** range,
            gint* range_length1)
{
	return window_construct (TYPE_WINDOW, nb, range, range_length1);
}

static void
window_loading_data_free (gpointer _data)
{
	WindowLoadingData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (WindowLoadingData, _data_);
}

void
window_loading (Window* self,
                GAsyncReadyCallback _callback_,
                gpointer _user_data_)
{
	WindowLoadingData* _data_;
	Window* _tmp0_;
	g_return_if_fail (self != NULL);
	_data_ = g_slice_new0 (WindowLoadingData);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, window_loading_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	window_loading_co (_data_);
}

void
window_loading_finish (Window* self,
                       GAsyncResult* _res_)
{
	WindowLoadingData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		Window* self;
		self = _data1_->self;
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}

static void
window_loading_ready (GObject* source_object,
                      GAsyncResult* _res_,
                      gpointer _user_data_)
{
	WindowLoadingData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	window_loading_co (_data_);
}

static gboolean
_window_loading_co_gsource_func (gpointer self)
{
	gboolean result;
	result = window_loading_co (self);
	return result;
}

static gchar*
_vala_lambda1_ (Block1Data* _data1_)
{
	Window* self;
	GString* tab_str = NULL;
	GString* _tmp0_;
	gchar* output = NULL;
	gint* _tmp1_;
	gint _tmp1__length1;
	GString* _tmp3_;
	const gchar* _tmp4_;
	GError* _inner_error0_ = NULL;
	gchar* result;
	self = _data1_->self;
	_tmp0_ = g_string_sized_new ((gsize) 16384);
	tab_str = _tmp0_;
	_tmp1_ = self->priv->tab;
	_tmp1__length1 = self->priv->tab_length1;
	{
		gint* i_collection = NULL;
		gint i_collection_length1 = 0;
		gint _i_collection_size_ = 0;
		gint i_it = 0;
		i_collection = _tmp1_;
		i_collection_length1 = _tmp1__length1;
		for (i_it = 0; i_it < i_collection_length1; i_it = i_it + 1) {
			gint i = 0;
			i = i_collection[i_it];
			{
				GString* _tmp2_;
				_tmp2_ = tab_str;
				g_string_append_printf (_tmp2_, "%d ", i);
			}
		}
	}
	_tmp3_ = tab_str;
	_tmp4_ = _tmp3_->str;
	g_print ("Input :[%s]", _tmp4_);
	{
		const gchar* _tmp5_;
		gchar* _tmp6_;
		GString* _tmp7_;
		const gchar* _tmp8_;
		gchar* _tmp9_;
		gchar** _tmp10_;
		gchar** _tmp11_;
		gint _tmp11__length1;
		gchar* _tmp12_ = NULL;
		_tmp5_ = PUSH_SWAP_EMP;
		_tmp6_ = g_strdup (_tmp5_);
		_tmp7_ = tab_str;
		_tmp8_ = _tmp7_->str;
		_tmp9_ = g_strdup (_tmp8_);
		_tmp10_ = g_new0 (gchar*, 2 + 1);
		_tmp10_[0] = _tmp6_;
		_tmp10_[1] = _tmp9_;
		_tmp11_ = _tmp10_;
		_tmp11__length1 = 2;
		g_spawn_sync (NULL, _tmp11_, NULL, 0, NULL, NULL, &_tmp12_, NULL, NULL, &_inner_error0_);
		_g_free0 (output);
		output = _tmp12_;
		_tmp11_ = (_vala_array_free (_tmp11_, _tmp11__length1, (GDestroyNotify) g_free), NULL);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp13_;
		const gchar* _tmp14_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp13_ = e;
		_tmp14_ = _tmp13_->message;
		g_printerr ("%s", _tmp14_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_free0 (output);
		_g_string_free0 (tab_str);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _window_loading_co_gsource_func, _data1_->_async_data_, NULL);
	result = output;
	_g_string_free0 (tab_str);
	return result;
}

static gpointer
__vala_lambda1__gthread_func (gpointer self)
{
	gpointer result;
	result = _vala_lambda1_ (self);
	block1_data_unref (self);
	return result;
}

static gboolean
window_loading_co (WindowLoadingData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_data1_ = g_slice_new0 (Block1Data);
	_data_->_data1_->_ref_count_ = 1;
	_data_->_data1_->self = g_object_ref (_data_->self);
	_data_->_data1_->_async_data_ = _data_;
	_data_->_tmp0_ = _data_->self->priv->_is_running;
	if (_data_->_tmp0_ == TRUE) {
		window_set_is_killing (_data_->self, TRUE);
		_data_->_tmp1_ = _data_->self->priv->book;
		g_object_set (_data_->_tmp1_, "page", 1, NULL);
		while (TRUE) {
			_data_->_tmp2_ = _data_->self->priv->_is_killing;
			if (!(_data_->_tmp2_ == TRUE)) {
				break;
			}
			_data_->_state_ = 1;
			utils_sleep (500, window_loading_ready, _data_);
			return FALSE;
			_state_1:
			utils_sleep_finish (_data_->_res_);
		}
	}
	window_set_is_running (_data_->self, TRUE);
	_data_->_tmp3_ = _data_->self->priv->book;
	g_object_set (_data_->_tmp3_, "page", 1, NULL);
	_data_->_tmp4_ = _data_->self->priv->_is_replay;
	if (_data_->_tmp4_ == FALSE) {
		_data_->_tmp5_ = 0;
		_data_->_tmp6_ = utils_get_random_tab (_data_->self->priv->nb_max, &_data_->_tmp5_);
		_data_->self->priv->tab = (g_free (_data_->self->priv->tab), NULL);
		_data_->self->priv->tab = _data_->_tmp6_;
		_data_->self->priv->tab_length1 = _data_->_tmp5_;
		_data_->self->priv->_tab_size_ = _data_->self->priv->tab_length1;
		_data_->_tmp7_ = g_thread_new (NULL, __vala_lambda1__gthread_func, block1_data_ref (_data_->_data1_));
		_data_->thread = _data_->_tmp7_;
		_data_->_state_ = 2;
		return FALSE;
		_state_2:
		;
		_data_->_tmp8_ = _data_->thread;
		_data_->thread = NULL;
		_data_->_tmp9_ = g_thread_join (_data_->_tmp8_);
		_g_free0 (_data_->self->priv->stream);
		_data_->self->priv->stream = (gchar*) _data_->_tmp9_;
		_g_thread_unref0 (_data_->thread);
	}
	_data_->_tmp10_ = _data_->self->priv->stackA;
	g_queue_clear (_data_->_tmp10_);
	_data_->_tmp11_ = _data_->self->priv->stackB;
	g_queue_clear (_data_->_tmp11_);
	_data_->_tmp12_ = _data_->self->priv->menu;
	menu_iterate_count (_data_->_tmp12_, "", 0);
	_data_->_tmp13_ = _data_->self->priv->tab;
	_data_->_tmp13__length1 = _data_->self->priv->tab_length1;
	{
		_data_->i_collection_length1 = 0;
		_data_->_i_collection_size_ = 0;
		_data_->i_collection = _data_->_tmp13_;
		_data_->i_collection_length1 = _data_->_tmp13__length1;
		for (_data_->i_it = 0; _data_->i_it < _data_->i_collection_length1; _data_->i_it = _data_->i_it + 1) {
			_data_->i = _data_->i_collection[_data_->i_it];
			{
				_data_->_tmp14_ = _data_->self->priv->stackA;
				g_queue_push_tail (_data_->_tmp14_, (gpointer) ((gintptr) _data_->i));
			}
		}
	}
	_data_->_tmp15_ = _data_->self->priv->book;
	g_object_set (_data_->_tmp15_, "page", 0, NULL);
	_data_->_tmp16_ = _data_->self->priv->stream;
	window_run_programme (_data_->self, _data_->_tmp16_, NULL, NULL);
	block1_data_unref (_data_->_data1_);
	_data_->_data1_ = NULL;
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
window_run_programme_data_free (gpointer _data)
{
	WindowRunProgrammeData* _data_;
	_data_ = _data;
	_g_free0 (_data_->stream);
	_g_object_unref0 (_data_->self);
	g_slice_free (WindowRunProgrammeData, _data_);
}

static void
window_run_programme (Window* self,
                      const gchar* stream,
                      GAsyncReadyCallback _callback_,
                      gpointer _user_data_)
{
	WindowRunProgrammeData* _data_;
	Window* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (stream != NULL);
	_data_ = g_slice_new0 (WindowRunProgrammeData);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, window_run_programme_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = g_strdup (stream);
	_g_free0 (_data_->stream);
	_data_->stream = _tmp1_;
	window_run_programme_co (_data_);
}

static void
window_run_programme_finish (Window* self,
                             GAsyncResult* _res_)
{
	WindowRunProgrammeData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static gchar*
string_strip (const gchar* self)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}

static inline GRegex*
_thread_safe_regex_init (GRegex** re,
                         const gchar * pattern,
                         GRegexCompileFlags compile_flags)
{
	if (g_once_init_enter ((volatile gsize*) re)) {
		GRegex* val = g_regex_new (pattern, compile_flags, 0, NULL);
		g_once_init_leave ((volatile gsize*) re, (gsize) val);
	}
	return *re;
}

static gpointer
_g_regex_ref0 (gpointer self)
{
	return self ? g_regex_ref (self) : NULL;
}

static void
_vala_array_add2 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static gchar**
_vala_array_dup1 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static void
window_run_programme_ready (GObject* source_object,
                            GAsyncResult* _res_,
                            gpointer _user_data_)
{
	WindowRunProgrammeData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	window_run_programme_co (_data_);
}

static gboolean
window_run_programme_co (WindowRunProgrammeData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = string_strip (_data_->stream);
	_data_->_tmp1_ = _data_->_tmp0_;
	_data_->_tmp3_ = _data_->_tmp2_ = g_strsplit (_data_->_tmp1_, "\n", 0);
	_data_->_tmp4_ = _data_->_tmp3_;
	_data_->_tmp4__length1 = _vala_array_length (_data_->_tmp2_);
	_g_free0 (_data_->_tmp1_);
	_data_->split = _data_->_tmp4_;
	_data_->split_length1 = _data_->_tmp4__length1;
	_data_->_split_size_ = _data_->split_length1;
	_data_->_tmp5_ = g_new0 (gchar*, 0 + 1);
	_data_->tmp = _data_->_tmp5_;
	_data_->tmp_length1 = 0;
	_data_->_tmp_size_ = _data_->tmp_length1;
	_data_->count = 0;
	_data_->self->priv->target = 0;
	_data_->_tmp6_ = _g_regex_ref0 (_thread_safe_regex_init (&_tmp_regex_0, "^sa$|^sb$|^ss$|^pa$|^pb$|^ra$|^rb$|^rr$|^rra$|^rrb$|^rrr$", 0));
	_data_->regex = _data_->_tmp6_;
	_data_->_tmp7_ = _data_->split;
	_data_->_tmp7__length1 = _data_->split_length1;
	{
		_data_->i_collection_length1 = 0;
		_data_->_i_collection_size_ = 0;
		_data_->i_collection = _data_->_tmp7_;
		_data_->i_collection_length1 = _data_->_tmp7__length1;
		for (_data_->i_it = 0; _data_->i_it < _data_->i_collection_length1; _data_->i_it = _data_->i_it + 1) {
			_data_->_tmp8_ = g_strdup (_data_->i_collection[_data_->i_it]);
			_data_->i = _data_->_tmp8_;
			{
				_data_->_tmp9_ = _data_->regex;
				_data_->_tmp10_ = _data_->i;
				if (g_regex_match (_data_->_tmp9_, _data_->_tmp10_, 0, NULL)) {
					_data_->_tmp11_ = _data_->i;
					_data_->_tmp12_ = g_strdup (_data_->_tmp11_);
					_vala_array_add2 (&_data_->tmp, &_data_->tmp_length1, &_data_->_tmp_size_, _data_->_tmp12_);
				}
				_g_free0 (_data_->i);
			}
		}
	}
	_data_->_tmp13_ = _data_->tmp;
	_data_->_tmp13__length1 = _data_->tmp_length1;
	_data_->_tmp14_ = (_data_->_tmp13_ != NULL) ? _vala_array_dup1 (_data_->_tmp13_, _data_->_tmp13__length1) : _data_->_tmp13_;
	_data_->_tmp14__length1 = _data_->_tmp13__length1;
	_data_->split = (_vala_array_free (_data_->split, _data_->split_length1, (GDestroyNotify) g_free), NULL);
	_data_->split = _data_->_tmp14_;
	_data_->split_length1 = _data_->_tmp14__length1;
	_data_->_split_size_ = _data_->split_length1;
	_data_->_tmp15_ = _data_->split;
	_data_->_tmp15__length1 = _data_->split_length1;
	_data_->split_len = _data_->_tmp15__length1;
	_data_->_tmp16_ = _data_->self->priv->scale;
	gtk_range_set_value ((GtkRange*) _data_->_tmp16_, (gdouble) 0);
	_data_->_tmp17_ = _data_->self->priv->scale;
	gtk_range_set_range ((GtkRange*) _data_->_tmp17_, 0.0, (gdouble) _data_->split_len);
	while (TRUE) {
		_data_->_tmp18_ = _data_->self->priv->_speed;
		_data_->_state_ = 1;
		utils_usleep (_data_->_tmp18_, window_run_programme_ready, _data_);
		return FALSE;
		_state_1:
		utils_usleep_finish (_data_->_res_);
		while (TRUE) {
			_data_->_tmp20_ = _data_->self->priv->_is_stop;
			if (_data_->_tmp20_) {
				_data_->_tmp21_ = _data_->self->priv->_is_killing;
				_data_->_tmp19_ = _data_->_tmp21_ == FALSE;
			} else {
				_data_->_tmp19_ = FALSE;
			}
			if (!_data_->_tmp19_) {
				break;
			}
			_data_->_state_ = 2;
			utils_sleep (200, window_run_programme_ready, _data_);
			return FALSE;
			_state_2:
			utils_sleep_finish (_data_->_res_);
			_data_->_tmp22_ = _data_->self->priv->_is_step;
			if (_data_->_tmp22_ == TRUE) {
				window_set_is_step (_data_->self, FALSE);
				if (_data_->self->priv->target < _data_->split_len) {
					_data_->_tmp23_ = _data_->self->priv->target;
					_data_->self->priv->target = _data_->_tmp23_ + 1;
				}
				break;
			}
			_data_->_tmp24_ = _data_->self->priv->_is_backstep;
			if (_data_->_tmp24_ == TRUE) {
				window_set_is_backstep (_data_->self, FALSE);
				if (_data_->self->priv->target > 0) {
					_data_->_tmp25_ = _data_->self->priv->target;
					_data_->self->priv->target = _data_->_tmp25_ - 1;
				}
				break;
			}
		}
		_data_->_tmp26_ = _data_->self->priv->_is_killing;
		if (_data_->_tmp26_ == TRUE) {
			window_set_is_killing (_data_->self, FALSE);
			_g_regex_unref0 (_data_->regex);
			_data_->tmp = (_vala_array_free (_data_->tmp, _data_->tmp_length1, (GDestroyNotify) g_free), NULL);
			_data_->split = (_vala_array_free (_data_->split, _data_->split_length1, (GDestroyNotify) g_free), NULL);
			g_task_return_pointer (_data_->_async_result, _data_, NULL);
			if (_data_->_state_ != 0) {
				while (!g_task_get_completed (_data_->_async_result)) {
					g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
				}
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		_data_->_tmp28_ = _data_->self->priv->_is_stop;
		if (_data_->_tmp28_ == FALSE) {
			_data_->_tmp29_ = _data_->self->priv->_is_scaling;
			_data_->_tmp27_ = _data_->_tmp29_ == FALSE;
		} else {
			_data_->_tmp27_ = FALSE;
		}
		if (_data_->_tmp27_) {
			_data_->_tmp30_ = _data_->self->priv->_is_reverse;
			if (_data_->_tmp30_) {
				if (_data_->self->priv->target > 0) {
					_data_->_tmp31_ = _data_->self->priv->target;
					_data_->self->priv->target = _data_->_tmp31_ - 1;
				}
			} else {
				if (_data_->self->priv->target < _data_->split_len) {
					_data_->_tmp32_ = _data_->self->priv->target;
					_data_->self->priv->target = _data_->_tmp32_ + 1;
				}
			}
		}
		if (_data_->self->priv->target > _data_->count) {
			if (_data_->count < _data_->split_len) {
				_data_->_tmp33_ = _data_->split;
				_data_->_tmp33__length1 = _data_->split_length1;
				_data_->_tmp34_ = _data_->_tmp33_[_data_->count];
				if (window_forward (_data_->self, _data_->_tmp34_)) {
					_data_->_tmp35_ = _data_->count;
					_data_->count = _data_->_tmp35_ + 1;
				}
			}
		} else {
			if (_data_->self->priv->target < _data_->count) {
				_data_->_tmp36_ = _data_->split;
				_data_->_tmp36__length1 = _data_->split_length1;
				_data_->_tmp37_ = _data_->_tmp36_[_data_->count - 1];
				if (window_reverse (_data_->self, _data_->_tmp37_)) {
					_data_->_tmp38_ = _data_->count;
					_data_->count = _data_->_tmp38_ - 1;
				}
			}
		}
		_data_->_tmp39_ = _data_->self->priv->scale;
		gtk_range_set_value ((GtkRange*) _data_->_tmp39_, (gdouble) _data_->self->priv->target);
		if (_data_->count == 0) {
			_data_->_tmp40_ = _data_->self->priv->menu;
			menu_iterate_count (_data_->_tmp40_, "", _data_->count);
		} else {
			_data_->_tmp41_ = _data_->self->priv->menu;
			_data_->_tmp42_ = _data_->split;
			_data_->_tmp42__length1 = _data_->split_length1;
			_data_->_tmp43_ = _data_->_tmp42_[_data_->count - 1];
			menu_iterate_count (_data_->_tmp41_, _data_->_tmp43_, _data_->count);
		}
		_data_->_tmp44_ = _data_->self->priv->draw_stackA;
		gtk_widget_queue_draw ((GtkWidget*) _data_->_tmp44_);
		_data_->_tmp45_ = _data_->self->priv->draw_stackB;
		gtk_widget_queue_draw ((GtkWidget*) _data_->_tmp45_);
	}
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

gboolean
window_reverse (Window* self,
                const gchar* line)
{
	const gchar* _tmp0_;
	GQuark _tmp2_ = 0U;
	static GQuark _tmp1_label0 = 0;
	static GQuark _tmp1_label1 = 0;
	static GQuark _tmp1_label2 = 0;
	static GQuark _tmp1_label3 = 0;
	static GQuark _tmp1_label4 = 0;
	static GQuark _tmp1_label5 = 0;
	static GQuark _tmp1_label6 = 0;
	static GQuark _tmp1_label7 = 0;
	static GQuark _tmp1_label8 = 0;
	static GQuark _tmp1_label9 = 0;
	static GQuark _tmp1_label10 = 0;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (line != NULL, FALSE);
	_tmp0_ = line;
	_tmp2_ = (NULL == _tmp0_) ? 0 : g_quark_from_string (_tmp0_);
	if (_tmp2_ == ((0 != _tmp1_label0) ? _tmp1_label0 : (_tmp1_label0 = g_quark_from_static_string ("ra")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp3_;
				_tmp3_ = self->priv->stackA;
				rra (_tmp3_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label1) ? _tmp1_label1 : (_tmp1_label1 = g_quark_from_static_string ("rra")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp4_;
				_tmp4_ = self->priv->stackA;
				ra (_tmp4_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label2) ? _tmp1_label2 : (_tmp1_label2 = g_quark_from_static_string ("sa")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp5_;
				_tmp5_ = self->priv->stackA;
				sa (_tmp5_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label3) ? _tmp1_label3 : (_tmp1_label3 = g_quark_from_static_string ("pa")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp6_;
				GQueue* _tmp7_;
				_tmp6_ = self->priv->stackA;
				_tmp7_ = self->priv->stackB;
				pb (_tmp6_, _tmp7_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label4) ? _tmp1_label4 : (_tmp1_label4 = g_quark_from_static_string ("rb")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp8_;
				_tmp8_ = self->priv->stackB;
				rrb (_tmp8_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label5) ? _tmp1_label5 : (_tmp1_label5 = g_quark_from_static_string ("rrb")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp9_;
				_tmp9_ = self->priv->stackB;
				rb (_tmp9_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label6) ? _tmp1_label6 : (_tmp1_label6 = g_quark_from_static_string ("sb")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp10_;
				_tmp10_ = self->priv->stackB;
				sb (_tmp10_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label7) ? _tmp1_label7 : (_tmp1_label7 = g_quark_from_static_string ("pb")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp11_;
				GQueue* _tmp12_;
				_tmp11_ = self->priv->stackA;
				_tmp12_ = self->priv->stackB;
				pa (_tmp11_, _tmp12_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label8) ? _tmp1_label8 : (_tmp1_label8 = g_quark_from_static_string ("ss")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp13_;
				GQueue* _tmp14_;
				_tmp13_ = self->priv->stackA;
				_tmp14_ = self->priv->stackB;
				ss (_tmp13_, _tmp14_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label9) ? _tmp1_label9 : (_tmp1_label9 = g_quark_from_static_string ("rr")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp15_;
				GQueue* _tmp16_;
				_tmp15_ = self->priv->stackA;
				_tmp16_ = self->priv->stackB;
				rrr (_tmp15_, _tmp16_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label10) ? _tmp1_label10 : (_tmp1_label10 = g_quark_from_static_string ("rrr")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp17_;
				GQueue* _tmp18_;
				_tmp17_ = self->priv->stackA;
				_tmp18_ = self->priv->stackB;
				rr (_tmp17_, _tmp18_);
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				g_warning ("Window.vala:208: %s", line);
				result = FALSE;
				return result;
			}
		}
	}
	result = TRUE;
	return result;
}

gboolean
window_forward (Window* self,
                const gchar* line)
{
	const gchar* _tmp0_;
	GQuark _tmp2_ = 0U;
	static GQuark _tmp1_label0 = 0;
	static GQuark _tmp1_label1 = 0;
	static GQuark _tmp1_label2 = 0;
	static GQuark _tmp1_label3 = 0;
	static GQuark _tmp1_label4 = 0;
	static GQuark _tmp1_label5 = 0;
	static GQuark _tmp1_label6 = 0;
	static GQuark _tmp1_label7 = 0;
	static GQuark _tmp1_label8 = 0;
	static GQuark _tmp1_label9 = 0;
	static GQuark _tmp1_label10 = 0;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (line != NULL, FALSE);
	_tmp0_ = line;
	_tmp2_ = (NULL == _tmp0_) ? 0 : g_quark_from_string (_tmp0_);
	if (_tmp2_ == ((0 != _tmp1_label0) ? _tmp1_label0 : (_tmp1_label0 = g_quark_from_static_string ("ra")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp3_;
				_tmp3_ = self->priv->stackA;
				ra (_tmp3_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label1) ? _tmp1_label1 : (_tmp1_label1 = g_quark_from_static_string ("rra")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp4_;
				_tmp4_ = self->priv->stackA;
				rra (_tmp4_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label2) ? _tmp1_label2 : (_tmp1_label2 = g_quark_from_static_string ("sa")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp5_;
				_tmp5_ = self->priv->stackA;
				sa (_tmp5_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label3) ? _tmp1_label3 : (_tmp1_label3 = g_quark_from_static_string ("pa")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp6_;
				GQueue* _tmp7_;
				_tmp6_ = self->priv->stackA;
				_tmp7_ = self->priv->stackB;
				pa (_tmp6_, _tmp7_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label4) ? _tmp1_label4 : (_tmp1_label4 = g_quark_from_static_string ("rb")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp8_;
				_tmp8_ = self->priv->stackB;
				rb (_tmp8_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label5) ? _tmp1_label5 : (_tmp1_label5 = g_quark_from_static_string ("rrb")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp9_;
				_tmp9_ = self->priv->stackB;
				rrb (_tmp9_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label6) ? _tmp1_label6 : (_tmp1_label6 = g_quark_from_static_string ("sb")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp10_;
				_tmp10_ = self->priv->stackB;
				sb (_tmp10_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label7) ? _tmp1_label7 : (_tmp1_label7 = g_quark_from_static_string ("pb")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp11_;
				GQueue* _tmp12_;
				_tmp11_ = self->priv->stackA;
				_tmp12_ = self->priv->stackB;
				pb (_tmp11_, _tmp12_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label8) ? _tmp1_label8 : (_tmp1_label8 = g_quark_from_static_string ("ss")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp13_;
				GQueue* _tmp14_;
				_tmp13_ = self->priv->stackA;
				_tmp14_ = self->priv->stackB;
				ss (_tmp13_, _tmp14_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label9) ? _tmp1_label9 : (_tmp1_label9 = g_quark_from_static_string ("rr")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp15_;
				GQueue* _tmp16_;
				_tmp15_ = self->priv->stackA;
				_tmp16_ = self->priv->stackB;
				rr (_tmp15_, _tmp16_);
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label10) ? _tmp1_label10 : (_tmp1_label10 = g_quark_from_static_string ("rrr")))) {
		switch (0) {
			default:
			{
				GQueue* _tmp17_;
				GQueue* _tmp18_;
				_tmp17_ = self->priv->stackA;
				_tmp18_ = self->priv->stackB;
				rrr (_tmp17_, _tmp18_);
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				g_warning ("Window.vala:260: %s", line);
				result = FALSE;
				return result;
			}
		}
	}
	result = TRUE;
	return result;
}

static void
_vala_lambda2_ (Window* self)
{
	window_set_is_running (self, FALSE);
	gtk_main_quit ();
}

static void
__vala_lambda2__gtk_widget_destroy (GtkWidget* _sender,
                                    gpointer self)
{
	_vala_lambda2_ ((Window*) self);
}

static void
_vala_lambda3_ (Window* self,
                gint speed)
{
	switch (speed) {
		case 1:
		{
			window_set_speed (self, 20000);
			break;
		}
		case 2:
		{
			window_set_speed (self, 10000);
			break;
		}
		case 3:
		{
			window_set_speed (self, 5000);
			break;
		}
		case 4:
		{
			window_set_speed (self, 2500);
			break;
		}
		case 5:
		{
			window_set_speed (self, 500);
			break;
		}
		case 6:
		{
			window_set_speed (self, 150);
			break;
		}
		case 7:
		{
			window_set_speed (self, 1);
			break;
		}
		default:
		break;
	}
}

static void
__vala_lambda3__menu_on_change_speed (Menu* _sender,
                                      gint speed,
                                      gpointer self)
{
	_vala_lambda3_ ((Window*) self, speed);
}

static gboolean
_vala_lambda5_ (Window* self)
{
	Menu* _tmp0_;
	gboolean result;
	window_loading (self, NULL, NULL);
	window_set_is_stop (self, TRUE);
	_tmp0_ = self->priv->menu;
	menu_scaling_mode (_tmp0_);
	result = FALSE;
	return result;
}

static gboolean
__vala_lambda5__gsource_func (gpointer self)
{
	gboolean result;
	result = _vala_lambda5_ ((Window*) self);
	return result;
}

static void
_vala_lambda4_ (Window* self,
                TypeEvent type)
{
	Menu* _tmp0_;
	window_set_is_scaling (self, FALSE);
	_tmp0_ = self->priv->menu;
	menu_refresh_speed (_tmp0_);
	switch (type) {
		case TYPE_EVENT_CONTINUE:
		{
			window_set_is_stop (self, FALSE);
			break;
		}
		case TYPE_EVENT_NEW:
		{
			g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, __vala_lambda5__gsource_func, g_object_ref (self), g_object_unref);
			break;
		}
		case TYPE_EVENT_STOP:
		{
			window_set_is_stop (self, TRUE);
			break;
		}
		case TYPE_EVENT_STEP:
		{
			window_set_is_stop (self, TRUE);
			window_set_is_step (self, TRUE);
			break;
		}
		case TYPE_EVENT_BACKSTEP:
		{
			window_set_is_stop (self, TRUE);
			window_set_is_backstep (self, TRUE);
			break;
		}
		case TYPE_EVENT_FORWARD:
		{
			window_set_is_reverse (self, FALSE);
			break;
		}
		case TYPE_EVENT_REVERSE:
		{
			window_set_is_reverse (self, TRUE);
			break;
		}
		default:
		break;
	}
}

static void
__vala_lambda4__menu_on_event (Menu* _sender,
                               TypeEvent type,
                               gpointer self)
{
	_vala_lambda4_ ((Window*) self, type);
}

static void
window_init_event (Window* self)
{
	Menu* _tmp0_;
	Menu* _tmp1_;
	g_return_if_fail (self != NULL);
	g_signal_connect_object ((GtkWidget*) self, "destroy", (GCallback) __vala_lambda2__gtk_widget_destroy, self, 0);
	_tmp0_ = self->priv->menu;
	g_signal_connect_object (_tmp0_, "on-change-speed", (GCallback) __vala_lambda3__menu_on_change_speed, self, 0);
	_tmp1_ = self->priv->menu;
	g_signal_connect_object (_tmp1_, "on-event", (GCallback) __vala_lambda4__menu_on_event, self, 0);
}

static gboolean
window_get_is_killing (Window* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_killing;
	return result;
}

static void
window_set_is_killing (Window* self,
                       gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_killing = value;
}

static gboolean
window_get_is_stop (Window* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_stop;
	return result;
}

static void
window_set_is_stop (Window* self,
                    gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_stop = value;
}

static gboolean
window_get_is_step (Window* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_step;
	return result;
}

static void
window_set_is_step (Window* self,
                    gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_step = value;
}

static gboolean
window_get_is_backstep (Window* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_backstep;
	return result;
}

static void
window_set_is_backstep (Window* self,
                        gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_backstep = value;
}

static gboolean
window_get_is_replay (Window* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_replay;
	return result;
}

static void
window_set_is_replay (Window* self,
                      gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_replay = value;
}

static gboolean
window_get_is_running (Window* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_running;
	return result;
}

static void
window_set_is_running (Window* self,
                       gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_running = value;
}

static gboolean
window_get_is_reverse (Window* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_reverse;
	return result;
}

static void
window_set_is_reverse (Window* self,
                       gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_reverse = value;
}

static gboolean
window_get_is_scaling (Window* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_scaling;
	return result;
}

static void
window_set_is_scaling (Window* self,
                       gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_scaling = value;
}

static gint
window_get_speed (Window* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_speed;
	return result;
}

static void
window_set_speed (Window* self,
                  gint value)
{
	g_return_if_fail (self != NULL);
	self->priv->_speed = value;
}

static void
window_class_init (WindowClass * klass,
                   gpointer klass_data)
{
	window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &Window_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_window_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_window_set_property;
	G_OBJECT_CLASS (klass)->finalize = window_finalize;
}

static void
window_instance_init (Window * self,
                      gpointer klass)
{
	self->priv = window_get_instance_private (self);
	self->priv->_is_killing = FALSE;
	self->priv->_is_stop = TRUE;
	self->priv->_is_step = FALSE;
	self->priv->_is_backstep = FALSE;
	self->priv->_is_replay = FALSE;
	self->priv->_is_running = FALSE;
	self->priv->_is_reverse = FALSE;
	self->priv->_is_scaling = FALSE;
	self->priv->_speed = 4000;
}

static void
window_finalize (GObject * obj)
{
	Window * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_WINDOW, Window);
	_g_object_unref0 (self->priv->draw_stackA);
	_g_object_unref0 (self->priv->draw_stackB);
	_g_object_unref0 (self->priv->menu);
	_g_object_unref0 (self->priv->box);
	_g_object_unref0 (self->priv->book);
	_g_object_unref0 (self->priv->scale);
	_g_free0 (self->priv->stream);
	self->priv->tab = (g_free (self->priv->tab), NULL);
	(self->priv->stackA == NULL) ? NULL : (self->priv->stackA = (g_queue_free (self->priv->stackA), NULL));
	(self->priv->stackB == NULL) ? NULL : (self->priv->stackB = (g_queue_free (self->priv->stackB), NULL));
	G_OBJECT_CLASS (window_parent_class)->finalize (obj);
}

static GType
window_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (WindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Window), 0, (GInstanceInitFunc) window_instance_init, NULL };
	GType window_type_id;
	window_type_id = g_type_register_static (gtk_window_get_type (), "Window", &g_define_type_info, 0);
	Window_private_offset = g_type_add_instance_private (window_type_id, sizeof (WindowPrivate));
	return window_type_id;
}

GType
window_get_type (void)
{
	static volatile gsize window_type_id__once = 0;
	if (g_once_init_enter (&window_type_id__once)) {
		GType window_type_id;
		window_type_id = window_get_type_once ();
		g_once_init_leave (&window_type_id__once, window_type_id);
	}
	return window_type_id__once;
}

static void
_vala_window_get_property (GObject * object,
                           guint property_id,
                           GValue * value,
                           GParamSpec * pspec)
{
	Window * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_WINDOW, Window);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_window_set_property (GObject * object,
                           guint property_id,
                           const GValue * value,
                           GParamSpec * pspec)
{
	Window * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_WINDOW, Window);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gssize
_vala_array_length (gpointer array)
{
	gssize length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

