/* Drawer.c generated by valac 0.57.0.224-bccf, the Vala compiler
 * generated from Drawer.vala, do not modify */

/*valac main.vala Window.vala Menu.vala Drawer.vala --pkg=gtk+-3.0*/

#include <gtk/gtk.h>
#include <glib-object.h>
#include <glib.h>
#include <cairo-gobject.h>
#include <float.h>
#include <math.h>

#if !defined(VALA_EXTERN)
#if defined(_WIN32) || defined(__CYGWIN__)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_DRAW_STACK (draw_stack_get_type ())
#define DRAW_STACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DRAW_STACK, DrawStack))
#define DRAW_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DRAW_STACK, DrawStackClass))
#define IS_DRAW_STACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DRAW_STACK))
#define IS_DRAW_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DRAW_STACK))
#define DRAW_STACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DRAW_STACK, DrawStackClass))

typedef struct _DrawStack DrawStack;
typedef struct _DrawStackClass DrawStackClass;
typedef struct _DrawStackPrivate DrawStackPrivate;
enum  {
	DRAW_STACK_0_PROPERTY,
	DRAW_STACK_NUM_PROPERTIES
};
static GParamSpec* draw_stack_properties[DRAW_STACK_NUM_PROPERTIES];

struct _DrawStack {
	GtkDrawingArea parent_instance;
	DrawStackPrivate * priv;
};

struct _DrawStackClass {
	GtkDrawingAreaClass parent_class;
};

struct _DrawStackPrivate {
	GQueue* stack;
	gint len_max;
};

static gint DrawStack_private_offset;
static gpointer draw_stack_parent_class = NULL;

VALA_EXTERN GType draw_stack_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (DrawStack, g_object_unref)
VALA_EXTERN DrawStack* draw_stack_new (GQueue** stack,
                           gint len_max);
VALA_EXTERN DrawStack* draw_stack_construct (GType object_type,
                                 GQueue** stack,
                                 gint len_max);
VALA_EXTERN gboolean draw_stack_drawing (DrawStack* self,
                             cairo_t* ctx);
static gboolean _draw_stack_drawing_gtk_widget_draw (GtkWidget* _sender,
                                              cairo_t* cr,
                                              gpointer self);
static void draw_stack_finalize (GObject * obj);
static GType draw_stack_get_type_once (void);

static inline gpointer
draw_stack_get_instance_private (DrawStack* self)
{
	return G_STRUCT_MEMBER_P (self, DrawStack_private_offset);
}

static gboolean
_draw_stack_drawing_gtk_widget_draw (GtkWidget* _sender,
                                     cairo_t* cr,
                                     gpointer self)
{
	gboolean result;
	result = draw_stack_drawing ((DrawStack*) self, cr);
	return result;
}

DrawStack*
draw_stack_construct (GType object_type,
                      GQueue** stack,
                      gint len_max)
{
	DrawStack * self = NULL;
	g_return_val_if_fail (*stack != NULL, NULL);
	self = (DrawStack*) g_object_new (object_type, "expand", TRUE, "hexpand", TRUE, "vexpand", TRUE, NULL);
	self->priv->stack = *stack;
	g_signal_connect_object ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_drawing_area_get_type (), GtkDrawingArea), "draw", (GCallback) _draw_stack_drawing_gtk_widget_draw, self, 0);
	self->priv->len_max = len_max;
	return self;
}

DrawStack*
draw_stack_new (GQueue** stack,
                gint len_max)
{
	return draw_stack_construct (TYPE_DRAW_STACK, stack, len_max);
}

gboolean
draw_stack_drawing (DrawStack* self,
                    cairo_t* ctx)
{
	gdouble color_a = 0.0;
	gdouble y = 0.0;
	gint G_ZOOM = 0;
	gdouble G_SIZE = 0.0;
	GQueue* copy = NULL;
	GQueue* _tmp0_;
	GQueue* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (ctx != NULL, FALSE);
	if (self->priv->len_max <= 10) {
		G_ZOOM = 40;
		G_SIZE = 30.0;
	} else {
		if (self->priv->len_max <= 25) {
			G_ZOOM = 20;
			G_SIZE = 10.0;
		} else {
			if (self->priv->len_max <= 50) {
				G_ZOOM = 7;
				G_SIZE = 8.0;
			} else {
				if (self->priv->len_max <= 100) {
					G_ZOOM = 5;
					G_SIZE = 3.8;
				} else {
					if (self->priv->len_max <= 150) {
						G_ZOOM = 3;
						G_SIZE = (gdouble) 2;
					} else {
						if (self->priv->len_max <= 350) {
							G_ZOOM = 2;
							G_SIZE = 1.5;
						} else {
							if (self->priv->len_max <= 520) {
								G_ZOOM = 1;
								G_SIZE = 0.7;
							} else {
								G_ZOOM = 1;
								G_SIZE = 0.5;
							}
						}
					}
				}
			}
		}
	}
	y = (gdouble) G_ZOOM;
	_tmp0_ = self->priv->stack;
	_tmp1_ = g_queue_copy (_tmp0_);
	copy = _tmp1_;
	cairo_set_line_width (ctx, (gdouble) 1);
	while (TRUE) {
		GQueue* _tmp2_;
		gdouble item = 0.0;
		GQueue* _tmp3_;
		gpointer _tmp4_;
		_tmp2_ = copy;
		if (!(g_queue_get_length (_tmp2_) != ((guint) 0))) {
			break;
		}
		_tmp3_ = copy;
		_tmp4_ = g_queue_pop_head (_tmp3_);
		item = (gdouble) ((gint) ((gintptr) _tmp4_));
		color_a = (item / self->priv->len_max) + 0.2;
		cairo_set_source_rgb (ctx, color_a, (gdouble) 0, (gdouble) 0);
		cairo_set_line_width (ctx, (gdouble) G_ZOOM);
		cairo_move_to (ctx, (gdouble) 0, y);
		cairo_line_to (ctx, item * G_SIZE, y);
		y += (gdouble) G_ZOOM;
		cairo_stroke (ctx);
	}
	result = TRUE;
	(copy == NULL) ? NULL : (copy = (g_queue_free (copy), NULL));
	return result;
}

static void
draw_stack_class_init (DrawStackClass * klass,
                       gpointer klass_data)
{
	draw_stack_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &DrawStack_private_offset);
	G_OBJECT_CLASS (klass)->finalize = draw_stack_finalize;
}

static void
draw_stack_instance_init (DrawStack * self,
                          gpointer klass)
{
	self->priv = draw_stack_get_instance_private (self);
}

static void
draw_stack_finalize (GObject * obj)
{
	DrawStack * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DRAW_STACK, DrawStack);
	G_OBJECT_CLASS (draw_stack_parent_class)->finalize (obj);
}

static GType
draw_stack_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (DrawStackClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) draw_stack_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DrawStack), 0, (GInstanceInitFunc) draw_stack_instance_init, NULL };
	GType draw_stack_type_id;
	draw_stack_type_id = g_type_register_static (gtk_drawing_area_get_type (), "DrawStack", &g_define_type_info, 0);
	DrawStack_private_offset = g_type_add_instance_private (draw_stack_type_id, sizeof (DrawStackPrivate));
	return draw_stack_type_id;
}

GType
draw_stack_get_type (void)
{
	static volatile gsize draw_stack_type_id__once = 0;
	if (g_once_init_enter (&draw_stack_type_id__once)) {
		GType draw_stack_type_id;
		draw_stack_type_id = draw_stack_get_type_once ();
		g_once_init_leave (&draw_stack_type_id__once, draw_stack_type_id);
	}
	return draw_stack_type_id__once;
}

